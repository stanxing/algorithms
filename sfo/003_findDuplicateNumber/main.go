package main

import "fmt"

// 寻找数组中重复的数字
// 在一个长度为 n 的数组里所有的数字都在 0～n+1 的范围内，请找出任意一个重复的数字。
// 解法1：将数组排序，然后遍历比较 i 和 i+1 即可得到重复数字，缺点很明显，时间复杂度为排序的复杂度，即 O(nlogn)(快速排序)，空间复杂度为 O(1)
// 解法2：使用了一个 hashMap 保存遍历的元素，如果元素不存在则插入，如果存在说明找到了重复数字，时间复杂度为 O(n)，但空间复杂度也是 O(n)
// 解法3：注意题干中的关键信息，数组中的数字都是在 0~n-1 范围内，正好对应数组下标，可以利用数组下标和数字的对应关系来解这道题。
// 重新排列这个数组（但不是使用排序算法），从头到尾依次遍历这个数组中每个数字，当扫描到下标为 i 的数字时，首先比较这个数字 m 和下标 i 是否相等，如果相等，接着扫描下一个数字;如果不相等，再拿它和第 m 个数字比较，如果它和第 m 和数字相等，说明找到了重复元素，（该数字在第 i 和第 m 的位置都出现了）;如果它和第 m 个数字不相等，就把第 i 个数字和第 m 个数字交换，把 m 放在属于它的位置上。接下来第 i 位置上的数字继续和它对应的下标的数字比较，不相等再继续，这样重复这个比较过程，只要有相等的情况，就可以找到重复的数字。
// 这种解法只需要遍历一次数组，在循环过程中会嵌套一个循环，但是里面的循环只需要最多交换两次就可以把一个数字放在它该在的位置，所以实际上复杂度是 2*O(n)
// 而且没有引进新的数组，所以时间复杂度为 O(n)，空间复杂度为 O(1)
func findDuplicateNumber(array []int) int {
	if len(array) <= 1 {
		return -1
	}
	for i := 0; i < len(array); i++ {
		for array[i] != i {
			// 比较下标 i 的值 m 和第 m 个值的大小
			if array[i] == array[array[i]] {
				return array[i]
			}
			// 交换第 i 个数字和第 m 个数字
			array[i], array[array[i]] = array[array[i]], array[i]
		}
	}
	return -1
}

// 在不修改数组的情况下找出重复的数字
// 在长度为 n+1 的数组里所有的数字都在 1～n 的范围里，所以数组中至少有一个数字是重复的，请找出重复的数字。
// 解法1：很容易想到的是创建一个辅助数组，遍历原数组依次将辅助数组对应下标的值记为1,通过判断辅助数组中的值来确定是否重复。
// 这样做的空间复杂度是 O(n)
// 解法2：
func findDuplicateNumberWithoutChangingArray(array []int) int {
	return 0
}

func main() {
	fmt.Println(findDuplicateNumber([]int{4, 3, 1, 0, 2, 5, 3}))
}
